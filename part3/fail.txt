30-shadowing.vsop... FAIL

Your compiler's output differs from expected output.

Here is the input file:
----------------- 8< -----------------
(* This class abuses shadowing to obscure the code, but is correct VSOP code *)
class Main extends Object {
    aName : bool;

    someMethod(aName : int32) : unit {
        printInt32(aName); // Uses the argument, not the field
        let aName : string <- "\n"
        in print(aName); // Uses the local variable, not the argument
        aName <- 42; // Use the argument again
        ()
    }

    main() : int32 {
        if not aName // Uses the field
            then
                let aName : int32
                in { aName <- 42; // Uses the local variable
                     let aName : string <- "hello"
                     in print(aName); // Uses the second local variable
                     aName <- 0 // Uses the first local variable again
                   }
            else
                someMethod(42);
        0
    }
}
----------------- 8< -----------------

Here is your program's (standard) output:
----------------- 8< -----------------
[Class(Main, Object, [Field(aName, bool)], [Method(someMethod, [aName : int32], unit, [Call(self : Main, printInt32, [aName : int32]) : Object, Let(aName, string, "\x0a" : string, Call(self : Main, print, [aName : string]) : Object) : Object, Assign(aName, 42 : int32) : int32, () : unit] : unit), Method(main, [], int32, [If(UnOp(not, aName : bool) : bool, Let(aName, int32, [Assign(aName, 42 : int32) : int32, Let(aName, string, "hello" : string, Call(self : Main, print, [aName : string]) : Object) : Object, Assign(aName, 0 : int32) : int32] : unit) : unit, Call(self : Main, someMethod, [42 : int32]) : unit), 0 : int32] : int32)])]
----------------- 8< -----------------

Here is the expected standard output:
----------------- 8< -----------------
[Class(Main, Object, [Field(aName, bool)],
   [Method(someMethod, [aName : int32], unit,
      [Call(self : Main, printInt32, [aName : int32]) : Object,
       Let(aName, string, "\x0a" : string,
         Call(self : Main, print, [aName : string]) : Object)
       : Object, Assign(aName, 42 : int32) : int32, () : unit]
      : unit),
    Method(main, [], int32,
      [If(UnOp(not, aName : bool) : bool,
         Let(aName, int32,
           [Assign(aName, 42 : int32) : int32,
            Let(aName, string, "hello" : string,
              Call(self : Main, print, [aName : string]) : Object)
            : Object, Assign(aName, 0 : int32) : int32]
           : int32)
         : int32, Call(self : Main, someMethod, [42 : int32]) : unit)
       : unit, 0 : int32]
      : int32)])]
----------------- 8< -----------------

69-field-in-field.vsop... FAIL

An error was expected, but your compiler returned with 0, 
indicating success.

Here is the input file:
----------------- 8< -----------------
class MyClass {
    i : int32 <- 2;
    theAnswer : int32 <- 40 + i;
}
class Main { main() : int32 { 0 } }
----------------- 8< -----------------

Here is the expected error output:
----------------- 8< -----------------
69-field-in-field.vsop:3:31: semantic error:
  cannot use class fields in field initializers.
69-field-in-field.vsop:3:31: semantic error: use of unbound variable i.
----------------- 8< -----------------

70-method-in-field.vsop... FAIL

An error was expected, but your compiler returned with 0, 
indicating success.

Here is the input file:
----------------- 8< -----------------
class Parent {
    i() : int32 { 2 }
}
class Child extends Parent {
    theAnswer : int32 <- 40 + i();
}
class Main { main() : int32 { 0 } }
----------------- 8< -----------------

Here is the expected error output:
----------------- 8< -----------------
70-method-in-field.vsop:5:31: semantic error:
  cannot find method i in type <invalid-type>.
70-method-in-field.vsop:5:31: semantic error:
  cannot use self in field initializer.
70-method-in-field.vsop:5:31: semantic error: use of unbound variable self.
----------------- 8< -----------------
Your compiler detected an error, but input was valid.

Here is the input file:
----------------- 8< -----------------
class Main {
    main(): int32 {
        declaredBelow()
    }
    declaredBelow(): int32 {
        0
    }
}
----------------- 8< -----------------

Here is your program's error output:
----------------- 8< -----------------
77-declaration-order.vsop:1:1: semantic error: class Main has no method named declaredBelow
----------------- 8< -----------------

Here is the expected standard output:
----------------- 8< -----------------
[Class(Main, Object, [],
   [Method(main, [], int32, [Call(self : Main, declaredBelow, []) : int32]
      : int32),
    Method(declaredBelow, [], int32, [0 : int32] : int32)])]
----------------- 8< -----------------
146-field-in-field.vsop... FAIL

An error was expected, but your compiler returned with 0, 
indicating success.

Here is the input file:
----------------- 8< -----------------
class Parent {
    i : int32 <- 2;
}
class Child extends Parent {
    theAnswer : int32 <- 40 + i;
}
class Main { main() : int32 { 0 } }
----------------- 8< -----------------

Here is the expected error output:
----------------- 8< -----------------
146-field-in-field.vsop:5:31: semantic error:
  cannot use class fields in field initializers.
146-field-in-field.vsop:5:31: semantic error: use of unbound variable i.
----------------- 8< -----------------